"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@nestjs/common/constants");
const random_string_generator_util_1 = require("@nestjs/common/utils/random-string-generator.util");
const fast_safe_stringify_1 = require("fast-safe-stringify");
const hash = require("object-hash");
class ModuleTokenFactory {
    constructor() {
        this.moduleIdsCache = new WeakMap();
    }
    create(metatype, scope, dynamicModuleMetadata) {
        const moduleId = this.getModuleId(metatype);
        const moduleScope = this.reflectScope(metatype);
        const isSingleScoped = moduleScope === true;
        const opaqueToken = {
            id: moduleId,
            module: this.getModuleName(metatype),
            dynamic: this.getDynamicMetadataToken(dynamicModuleMetadata),
            scope: isSingleScoped ? this.getScopeStack(scope) : moduleScope,
        };
        return hash(opaqueToken, { ignoreUnknown: true });
    }
    getDynamicMetadataToken(dynamicModuleMetadata) {
        // Uses safeStringify instead of JSON.stringify to support circular dynamic modules
        // The replacer function is also required in order to obtain real class names
        // instead of the unified "Function" key
        return dynamicModuleMetadata
            ? fast_safe_stringify_1.default(dynamicModuleMetadata, this.replacer)
            : '';
    }
    getScopeStack(scope) {
        const reversedScope = scope.reverse();
        const firstGlobalIndex = reversedScope.findIndex(s => this.reflectScope(s) === 'global');
        scope.reverse();
        const stack = firstGlobalIndex >= 0
            ? scope.slice(scope.length - firstGlobalIndex - 1)
            : scope;
        return stack.map(module => module.name);
    }
    getModuleId(metatype) {
        let moduleId = this.moduleIdsCache.get(metatype);
        if (moduleId) {
            return moduleId;
        }
        moduleId = random_string_generator_util_1.randomStringGenerator();
        this.moduleIdsCache.set(metatype, moduleId);
        return moduleId;
    }
    getModuleName(metatype) {
        return metatype.name;
    }
    reflectScope(metatype) {
        const scope = Reflect.getMetadata(constants_1.SHARED_MODULE_METADATA, metatype);
        return scope ? scope : 'global';
    }
    replacer(key, value) {
        if (typeof value === 'function') {
            return value.name;
        }
        return value;
    }
}
exports.ModuleTokenFactory = ModuleTokenFactory;
